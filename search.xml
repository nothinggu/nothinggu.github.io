<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[教你搭博客]]></title>
    <url>%2F2017%2F05%2F07%2F%E6%95%99%E4%BD%A0%E6%90%AD%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 最初用了十五个小时左右亲手搭了一个博客,踩过了一个又一个坑,但同时学习到了很多东西,现在来教教大家怎么搭好一个具有个性的博客,我会尽量注重细节,让大家在搭建博客的过程中也有所收获. 初心 为什么我要搭建一个个人博客?为什么不使用博客平台呢?(如博客园,CSDN)首先,我要明确一个态度—-对于一个追求技术的人来说,博客不仅是技术的交流平台,更加类似于一个运用知识的平台.站主现在是一名学生,由于相关技术与知识全靠自学,所以不能拥有系统的知识,所以只能通过填补漏缺来弥补知识缺陷.对于我来说,搭建个人博客类似于做一个可供维护的项目,一切代码对于我来说是完全可控的,因此我希望对于技术有所追求的朋友搭建个人博客. 注意事项 现在搭建博客,是一件很容易的事情,网络提供给我们了很多模板,但为什么我花了很长时间才弄好它呢?其实搭建博客本身不是一件难事,困难在于不同的电脑上有很多微妙的不同,有时间可能是一个小小的插件,甚至是一点前端程序员无比熟悉的小知识点,就可以让小白绕很大一圈.本人最初接触过前端(现在主要写java),所以略有了解,如果遇到什么问题,大家可以留言或联系我,我会尽量解答. 最初准备现在我们开始吧! 首先准备好需要的工具: 我下载的是最新版Node.js git(这个貌似需要翻墙),没有翻墙的朋友从这里下载:点我 ok,先准备好这些,现在需要配置github,注意记住自己的账号(Username) 登陆后,右上角有个”加号”形标志,点击New repository,然后只需要填写Repository name内容，内容为Username.github.io，这个将作为你的博客域名]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10_java_环境变量设置]]></title>
    <url>%2F2017%2F05%2F06%2Fwin10_java_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[竟然忘了java环境变量怎么配了…丢人写下笔记 下载java开发工具包. 直接打开系统之后打开: 点击环境变量: 点击系统变量的新建: 变量值就是下载后的jdk路径: 最后打开Path,点击新建,引入”C:\Program Files\Java\jdk1.8.0_112\bin”,”%JAVA_HOME%bin”]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java异常处理(Exception handing)机制]]></title>
    <url>%2F2017%2F05%2F06%2F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[异常异常分类 异常对象都是派生于throwable类的实例: Error类说明java运行时存在内存错误或资源耗尽错误,出现这类错误,除了告诉用户,别无他法 Exception是需要关注的;它又分为RuntimeException和IOException 如果出现了RuntimeException,那么一定是你自己的问题 Error类或RuntimeException类的所有异常称为非受查(uncheck)异常,其他的异常成为受查(check)异常 受查异常 需要记住在以下情况中应该抛出异常: 调用一个抛出受查异常的方法时,如:FileInputSteam构造器 程序运行时发现错误,利用throw抛出一个受查异常 程序出现错误时,如:数组越界(ArrayIndexOutOfBoundsException) java虚拟机和运行时库内出现的内部错误 如果出现前两种异常之一,则必须告诉程序员调用这个方法可能会出现的异常,如果没有处理器捕获,当前执行的线程就会结束 对于可能被其他人调用的方法,应根据异常规范(exception specification),在方法首部声明者个可能的的异常: 12345678class MyAnimation&#123; . . . public Image loadImage(String s) throws IOException &#123; . . . &#125;&#125; 但是,无需声明java的内部错误,我们无法控制Error. 同样,不应该声明从RuntimeException继承的非受查异常: 12345678class MyAnimation&#123; . . . void drawImage(int i) throws ArrayIndexOutOfBoundsException &#123; . . . &#125;&#125; 这些异常完全在我们的控制之下,与其去说明异常,我们更应该将精力花费在修改程序上 总之,一个方法必须声明可能抛出的受查异常,非受查异常要么是错误(Error),要么是可以避免发生的RuntimeException 注意: 如果在子类中覆盖了一个父类的方法,子类声明的受查异常不可比父类的方法中声明的异常更为通用. 如果父类方法没有抛出任何受查异常,那么子类也不能抛出任何受查异常 抛出异常 对于一个已知的异常类: 找到一个合适的异常类 创建这个类的对象 将对象抛出 1234567891011121314String readData(Scanner in) throws EOFException&#123; . . . while (. . .) &#123; if (!in.hasNext()) &#123; if (n &lt; len) throw new EOFException(); &#125; . . . &#125; return s;&#125; 一旦方法抛出了异常,该方法就不会返回给调用者,我们就不必再为返回的默认值或错误代码担忧 创建异常12345678class FileFormatException extends IOException&#123; public FileFormatException() &#123;&#125; public FileFormatException(String gripe) &#123; super(gripe); &#125;&#125; 习惯上,定义的类包含两个构造器,一个是无参构造器,另一个是带有详细描述的构造器(父类Throwable的toString方法将会打印出详细信息) 自定义构造器代码例: 1234567891011121314String readData(BufferedReader in) throws FileFormatException&#123; . . . while (. . .) &#123; if (ch == -1) &#123; if (n &lt; len) throw new FileFormatException(); &#125; . . . &#125; return s;&#125; 捕获异常12345678910try&#123; code more code more code&#125;catch (ExceptionType e)&#123; handler for this type&#125; 如果在try语句块中抛出了在catch语句块中说明的异常类,那么: 程序将跳过try语句块其余的代码 执行catch子句中的处理代码(如果在try中没有抛出任何异常,跳过catch子句) 如果方法中任何代码抛出了在catch中没有声明的异常,那么这个方法会立即退出 代码说明: 12345678910111213141516public void read(String filename)&#123; try &#123; InputStream in = new FileInputStream(filename); int b; while ((b = in.read()) != -1) &#123; process input &#125; &#125; catch (IOException exception) &#123; exception.printStackTrace(); &#125;&#125; read方法可能抛出一个IOException,这将会跳出while循环,进入catch子句,并声称一个栈轨迹(stack trace) 通常,最好的办法是什么也不做,而是将异常传给调用者,让调用者去操心怎么做,如果采用这种方式,就必须声明这个方法可能会抛出的异常: 1public void read(String filename) throws IOException 捕获多异常12345678910111213141516try&#123; code that might throw exceptions&#125;catch (FileNotFoundException e)&#123; emergency action for missing files&#125;catch (UnknownHostException e)&#123; emergency action for unknown hosts&#125;catch (IOException e)&#123; emergency action for all other I/O problems&#125; 在JKD1.7之后,可以这样捕获异常: 1234catch (FileNotFoundException | UnknownHostException e)&#123; emergency action for missing files and unknown hosts&#125; 注意:捕获多个异常时,异常的变量为final 捕获多个异常不仅会使代码看起来更简洁,而且会使代码运行效率更快 finally语句 不管是否有异常被捕获,finally子句都必将被执行: 12345678910111213141516171819InputStream in = new FileInputStream(. . .);try&#123; // 1 code that might throw exceptions // 2&#125;catch (IOException e)&#123; // 3 show error message // 4&#125;finally&#123; // 5 in.close();&#125;// 6 1).代码没有抛出异常.执行:1.2.5.6 2).抛出一个可以在catch中捕获的异常: 如果catch没有抛出异常,执行:1.3.4.5.6 如果catch子句抛出一个异常,执行:1.3.5(异常被抛会给方法调用者) 3).代码抛出一个异常,但没有catch可以捕获到,执行:1.5 因此,finally子句是无论如何都会执行的,下面的例子会有令人意外的结果: 123456789101112public static int f(int n)&#123; try &#123; int r = n * n; return r; &#125; finally &#123; if (n == 2) return 0; &#125;&#125; 调用f(2),try子句return结果r = 4,但是finally必然执行,return 0并覆盖 r = 4.]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内部类总结]]></title>
    <url>%2F2017%2F05%2F06%2F%E5%86%85%E9%83%A8%E7%B1%BB%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[内部类是java中比较复杂的内容,接下来进行一些细节总结: 内部类(inner class)是定义在一个类中的类,这种技巧有什么好处呢? 内部类可以访问外部类中的数据,包括私有数据 内部类对于包中其它类来说是隐藏的 当想要定义一个回调(callback)函数时,可以使用匿名内部类,这样更为便捷 (回调函数:可以指出一个特定事件发生时应该采取的动作.例如在按下鼠标或选择某个菜单时应该采取什么行动) 使用内部类访问对象状态1234567891011121314public class TalkingClock&#123; private int interval; private boolean beep; public TalkingClock(int interval, boolean beep) &#123; . . . &#125; public void start() &#123; . . . &#125; public class TimePrinter implements ActionListener //内部类 &#123; . . . &#125;&#125; 内部类的详细代码: 12345678public class TimePrinter implements ActionListener&#123; public void actionPerformed(ActionEvent event) &#123; System.out.println("At the tone, the time is " + new Date()); if (beep) Toolkit.getDefaultToolkit().beep(); &#125;&#125; 可以发现,在内部类中的beep是外部类中的变量,这样的引用是如何做到的呢? 事实上,是通过这样一种方式调用的: 1if (outer.beep) Toolkit.getDefaultToolkit().beep(); 但是,outer并不是java中的关键字,可以看到,内部类并没有构造器,所以编译器隐式地给内部类了一个构造器: 1234public TimePrinter(TalkingClock clock)&#123; outer = clock;&#125; 内部类的特殊语法规则 内部类对外部类引用的语法还要复杂一点:outerclass.this表示外部类数据的引用,如: 12345678public class TimePrinter implements ActionListener&#123; public void actionPerformed(ActionEvent event) &#123; System.out.println("At the tone, the time is " + new Date()); if (outer.this.beep) Toolkit.getDefaultToolkit().beep(); &#125;&#125; 细节规则: 内部类中所有的静态域都必须是final,因为对于一个外部类的实例,我们希望它都只有唯一一个内部类实例 内部类不能有静态方法 局部内部类 如果内部类只在外部类的一个方法中调用了一次,我们可以采取使用局部内部类来简化代码: 1234567891011121314public void start()&#123; class TimePrinter implements ActionListener &#123; public void actionPerformed(ActionEvent event) &#123; System.out.println("At the tone, the time is " + new Date()); if (beep) Toolkit.getDefaultToolkit().beep(); &#125; &#125; ActionListener listener = new TimePrinter(); Timer t = new Timer(interval, listener); t.start();&#125; 局部内部类不能用public和private来声明,它的作用域只限于在这个局部的块中局部内部类的另一个优点是对外部世界完全隐蔽,即除了start()方法外,没有任何方法知道TimePrinter类 细节规则: 当局部内部类访问局部变量时,必须为final 12345678910111213int counter = 0;Date[] dates = new Date[100];for (int i = 0; i &lt; dates.length; i++) dates[i] = new Date() &#123; public int compareTo(Date other) &#123; counter++; //错误 return super.compareTo(other); &#125; &#125;;Arrays.sort(dates);System.out.println(counter + " comparisons."); 匿名内部类12345678910111213public void start(int interval, boolean beep)&#123; ActionListener listener = new ActionListener() &#123; public void actionPerformed(ActionEvent event) &#123; System.out.println("At the tone, the time is " + new Date()); if (beep) Toolkit.getDefaultToolkit().beep(); &#125; &#125;; Timer t = new Timer(interval, listener); t.start();&#125; 细节规则: 由于构造器的名字必须与类相同,但是匿名内部类没有名字,所以匿名内部类没有构造器]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类的设计技巧简单总结]]></title>
    <url>%2F2017%2F05%2F06%2F%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[保证数据的私有性(private): 为了实现一个类的良好封装性,一定不要使用其他的方式去声明成员变量,这是为了后期代码维护做的基本准备. 对数据初始化: 虽然编译器会自动对成员变量进行隐式初始化,但是为了可读性,应该为变量提供初始化或是利用构造器进行初始化(局部变量必须初始化). 不要在类中使用过多的基本类型: 意思是当类中存在多个基本数据类型时,用一个引用类型来包装这些基本类型,这样可以增强其可读性,且后期要替换这个类的名称也更简单. 并非所有的域都需要getter/setter: 例如:在一个Employee类中,雇员的薪水是可以有getter和setter的,但是雇员的雇佣日期就不应该有setter. 一个类的功能尽量不要太繁杂: 如果一个类的某些功能明显的可以分为两类,就应该将其分解. 类名/方法名的名称要可以体现其职责]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用java写一个简单的文件拷贝程序吧]]></title>
    <url>%2F2017%2F05%2F06%2F%E7%94%A8java%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E7%A8%8B%E5%BA%8F%E5%90%A7%2F</url>
    <content type="text"><![CDATA[代码: 12345678910111213141516171819202122232425262728293031public static void copyFile(String srcPath, String destPath) throws IOException &#123; //建立File对象的来源与目的 File src = new File(srcPath); File dest = new File(destPath); //由于只能拷贝文件,所以判定输入流是否为文件 if(!src.isFile()) &#123; System.out.println("只能拷贝文件!"); throw new IOException("只能拷贝文件!"); &#125; //文件输入输出 InputStream is = new FileInputStream(src); OutputStream os = new FileOutputStream(dest); //读取文件大小,并循环写出文件 byte[] flush = new byte[1024]; int len = 0; while(-1 != (len = is.read(flush))) &#123; os.write(flush, 0, len); &#125; //刷新此输出流并强制写出所有缓冲的输出字节 os.flush(); //释放资源(一般先打开的后关闭) os.close(); is.close(); System.out.println("拷贝成功!"); &#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中引用传递和值传递的理解]]></title>
    <url>%2F2017%2F05%2F06%2Fjava%E4%B8%AD%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8C%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[按值调用(call by value):表示方法接收的是调用者提供的值按引用调用(call by reference):表示方法接收的是调用者提供的地址 一个方法可以修改引用传递所对应的变量值,而不能修改值传递调用所对应的变量值 对于java来说,是不存在引用传递的,它总是按值调用 如何理解?方法是得到所有参数值的一个拷贝,方法无法修改传递给它的任何变量值的内容 示例1: 12345678910public static void main(String[] args) &#123; int temp = 0; int x = 10; int y = 11; System.out.println("before: " + x + " "+ y); // x = 10, y = 11 temp = y; y = x; x = temp; System.out.println("after: " + x + " "+ y); // x = 11, y = 10 &#125; 示例2: 1234567891011121314public static void main(String[] args) &#123; int temp = 0; int x = 10; int y = 11; System.out.println("before: " + x + " "+ y); // x = 10, y = 11 change(x, y); System.out.println("after: " + x + " "+ y); // x = 10, y = 11 &#125; public static void change(int x, int y) &#123; int temp = 0; temp = y; y = x; x = temp; &#125; 我们可以看到,一个方法不可以改变基本数据类型参数值,但可以通过引用类型来改变参数: 示例3: 123456789101112131415161718192021public static void main(String[] args) &#123; Test t1 = new Test("James", 15); plus(t1); System.out.println(t1.age); // 输出25 &#125; public static void plus(Test t)&#123; t.age += 10; &#125;&#125;class Test &#123; String name; int age; public Test(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; 最后,我们来试验一下引用类型是否可以对象交换: 示例4: 12345678910111213141516171819202122232425262728public static void main(String[] args) &#123; Test t1 = new Test("James", 15); Test t2 = new Test("Alice", 20); System.out.println(t1 + " " + t2); //t1 = test.Test@15db9742, t2 = test.Test@6d06d69c swap(t1, t2); System.out.println(t1 + " " + t2); //t1 = test.Test@15db9742, t2 = test.Test@6d06d69c &#125; public static void swap(Test t1, Test t2) &#123; Test temp = t1; t2 = t1; t1 = temp; &#125;&#125;class Test &#123; String name; int age; public Test(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public Integer plus(Integer age)&#123; age += 10; return age; &#125; 依旧是无法实现的]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用容器（Collection）实现类总结（四）——HashSet]]></title>
    <url>%2F2017%2F05%2F06%2F%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93-five%2F</url>
    <content type="text"><![CDATA[此类实现 Set 接口，由哈希表（实际上是一个 HashMap 实例）支持。它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用 null 元素。 (This class implements the Set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the null element. ) (注意:HashSet必须重写hashcode和equals方法) HashSet的优、缺点分析优点： 不允许储存相同的对象(注意:HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false) 缺点： 相较HashMap速度慢(HashMap由唯一的Key来找Value) 方法分析 HashSet的底层实现实际上是HashMap,主要分析其中一个方法add(): 123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 可见,传入的形参e是作为map的Key,而HashSet的元素不可重复实际上就是利用了Map中Key的不可重复 再看看PRESENT是什么: 1private static final Object PRESENT = new Object(); 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final]]></content>
      <categories>
        <category>DATA STRUCTURES</category>
      </categories>
      <tags>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用容器（Collection）实现类总结（三）——HashMap]]></title>
    <url>%2F2017%2F05%2F06%2F%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93_four%2F</url>
    <content type="text"><![CDATA[基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 (Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time. ) 此实现假定哈希函数将元素适当地分布在各桶(buckets)之间，可为基本操作（get 和 put）提供稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。 (This implementation provides constant-time performance for the basic operations (get and put), assuming the hash function disperses the elements properly among the buckets. Iteration over collection views requires time proportional to the “capacity” of the HashMap instance (the number of buckets) plus its size (the number of key-value mappings). Thus, it’s very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important. ) HashMap的优、缺点分析优点： 通过键值对(key-value)而构成一对一（也可以是一对多）的映射关系，方便数据的查询 由于HashMap只允许唯一键的存在，所以查询速度较快 缺点： 映射无序，且不保证顺序恒定 HashMap基本实现 Entry类的实现： 123456789101112class Entry &#123; Object key; Object value; public Entry() &#123;&#125; public Entry(Object key, Object value) &#123; super(); this.key = key; this.value = value; &#125;&#125; HashMap操作的是键值对,需要一个Entry类来实现 MyHashMap类的简单实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class MyHashMap &#123; Entry[] arr = new Entry[100]; int size; public void put(Object key, Object value) &#123; Entry e = new Entry(key, value); for(int i = 0;i &lt; size; i++) &#123; if(arr[i].key.equals(key)) &#123; arr[i].value = value; return ; &#125; &#125; //由于HashMap只允许存在唯一键,重复的键值对会被新值覆盖,所以引入这段代码 arr[size++] = e; &#125; public Object get(Object key) &#123; for(int i = 0;i &lt; size; i++) &#123; if(arr[i].key.equals(key)) &#123; return arr[i].value; &#125; &#125; return null; &#125; public void remove(Object key) &#123; for(int i = 0;i &lt; size; i++) &#123; if(arr[i].key.equals(key)) &#123; arr[i].value = null; size--; &#125; &#125; &#125; public boolean containsKey(Object key) &#123; for(int i = 0;i &lt; size; i++) &#123; if(arr[i].key.equals(key)) &#123; return true; &#125; &#125; return false; &#125; public boolean containsValue(Object value) &#123; for(int i = 0;i &lt; size; i++) &#123; if(arr[i].value.equals(value)) &#123; return true; &#125; &#125; return false; &#125; public int getSize() &#123; return size; &#125; public void setSize(int size) &#123; this.size = size; &#125; 显然,基本实现HashMap的方法效率低下,需要改进 HashMap改进版实际上,HashMap的底层实现是通过Array和LinkedList共同实现的,所以HashMap综合了两者的优点,实现的关键在于利用hashcode: 123456789//存储时:int hash = key.hashCode();int index = hash % Entry[].length;Entry[index] = value;//取值时:int hash = key.hashCode();int index = hash % Entry[].length;return Entry[index]; HashMap实现的图片说明: Entry类的升级: 1234567891011121314151617181920212223242526class Entry&lt;K,V&gt;&#123; final K key; V value; Entry&lt;K,V&gt; next;//下一个结点 public Entry(K key, V value, Entry&lt;K, V&gt; next) &#123; super(); this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125;&#125; MyHashMap类的实现: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MyHashMap&lt;K, V&gt; &#123; private Entry[] table; static final int DEFAULT_INITIAL_CAPACITY = 16;//默认数组长度 private int size; public Hash() &#123; table = new Entry[DEFAULT_INITIAL_CAPACITY]; size = DEFAULT_INITIAL_CAPACITY; &#125; public int getSize() &#123; return size; &#125; // 求index static int indexFor(int h, int length) &#123; return h % (length - 1); &#125; //获取value public V get(Object key) &#123; if (key == null) return null; int hash = key.hashCode(); int index = indexFor(hash, table.length);// 求key在数组中的下标 for (Entry&lt;K, V&gt; e = table[index]; e != null; e = e.next) &#123; Object k = e.key; if (e.key.hashCode() == hash &amp;&amp; (k == key || key.equals(k))) return e.value; &#125; return null; &#125; public V put(K key, V value) &#123; if (key == null) return null; int hash = key.hashCode(); int index = indexFor(hash, table.length); for (Entry&lt;K, V&gt; e = table[index]; e != null; e = e.next) &#123; Object k = e.key; if (e.key.hashCode() == hash &amp;&amp; (k == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; return oldValue; &#125; &#125; // 如果key值不存在，那么需要添加 Entry&lt;K, V&gt; e = table[index];// 获取当前数组中的e table[index] = new Entry&lt;K, V&gt;(key, value, e);// 新建一个Entry，并将其指向原先的e return null; &#125;&#125;]]></content>
      <categories>
        <category>DATA STRUCTURES</category>
      </categories>
      <tags>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用容器（Collection）实现类总结（二）——LinkedList]]></title>
    <url>%2F2017%2F05%2F06%2F%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93-three%2F</url>
    <content type="text"><![CDATA[List 接口的链接列表实现。实现所有可选的列表操作，并且允许所有元素（包括 null）。除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。 （Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null).All of the operations perform as could be expected for a doubly-linked list. Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index. ） 所有操作都是按照双重链接列表（doubly-linked list）的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。 （All of the operations perform as could be expected for a doubly-linked list. Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index. ） LinkedList的优、缺点分析优点： 操作的是数据指针，相对ArrayList大大增强了增、删速率 缺点： 查找速率较低 线程不安全 双向链表示意: 链表与泛型集合有一个重要区别:链表是一个有序集合,每个对象的位置很重要.LinkedList.add方法是将元素添加到列表的最后,但是有时我们需要在列表中插入一个元素,这时这时使用迭代器就很必要. 图例: 相关代码: 1234567List&lt;String&gt; staff = new LinkedList&lt;&gt;();staff.add("Amy");staff.add("Bob");staff.add("Carl");ListIterator&lt;String&gt; iter = staff.listIterator();iter.next(); // skip past first elementiter.add("Juliet"); 注意:这里有个调用remove方法的小细节——迭代器的删除和backspace工作方式有区别,在调用了next后,remove确实是删除了迭代后左侧的元素,但是在调用了previous之后,remove的是迭代后右侧的元素,并且不能连续调用两次remove. add只依赖于迭代器的位置,而remove注重迭代器的状态. 123456789101112public static void main(String[] args) &#123; List&lt;String&gt; l = new LinkedList&lt;&gt;(); l.add("a"); l.add("b"); l.add("c"); ListIterator&lt;String&gt; it = l.listIterator(); it.next(); it.add("some"); //在a后插入some it.previous(); it.remove(); System.out.println(l); //输出[a, b, c],删除的是some而非a &#125; 基本实现 Node类的实现：由于在链表中，出现了节点（Node）的概念，所以我们先写如一个节点类，来操控指针： 12345678910111213141516171819202122232425262728293031323334public class Node &#123; private Node previous; private Node next; private Object obj; public Node()&#123;&#125; public Node(Node previous, Node next, Object obj) &#123; super(); this.previous = previous; this.next = next; this.obj = obj; &#125; public Node getPrevious() &#123; return previous; &#125; public void setPrevious(Node previous) &#123; this.previous = previous; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node next) &#123; this.next = next; &#125; public Object getObj() &#123; return obj; &#125; public void setObj(Object obj) &#123; this.obj = obj; &#125; &#125; 我们所实现的是双向链表，因此我定义了next和previous两个变量，顾名思义，目的就是为了对一个数据进行前后操作，后面定义了一系列getter/setter方法以达到增、删的操作；object变量显然就是储存的数据了 LinkedList类的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class LinkList &#123; private Node first; private Node last; private int size; public void add(Object obj) &#123; Node n = new Node(); if(first == null) &#123; n.setPrevious(null); n.setObj(obj); n.setNext(null); first = n; last = n; &#125;else &#123; n.setPrevious(last); n.setObj(obj); n.setNext(null); last.setNext(n); last = n; &#125; size++; &#125; public void add(int index, Object obj) &#123; rangeCheck(index); Node temp = (Node) find(index); Node newNode = new Node(); Node prev = temp.getPrevious(); if(temp != null) &#123; newNode.setObj(obj); prev.setNext(newNode); newNode.setNext(temp); newNode.setPrevious(prev); temp.setPrevious(newNode); &#125; &#125; public void rangeCheck(int index) &#123; if(index &lt; 0 || index &gt;= this.size) &#123; try &#123; throw new Exception(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; public Object get(int index) &#123; rangeCheck(index); Node temp = find(index); if(temp != null) &#123; return temp.getObj(); &#125; return null; &#125; public void remove(int index) &#123; Node temp = find(index); if (temp != null) &#123; Node prev = temp.getPrevious(); Node next = temp.getNext(); prev.setNext(next); next.setPrevious(prev); size--; &#125; &#125; public Node find(int index) &#123; Node temp = first; if(first != null) &#123; for(int i = 0;i &lt; index; i++) &#123; temp = first; temp = temp.getNext(); &#125; &#125; return temp; &#125; public int getSize() &#123; return size; &#125;]]></content>
      <categories>
        <category>DATA STRUCTURES</category>
      </categories>
      <tags>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用容器（Collection）实现类总结（一）——ArrayList]]></title>
    <url>%2F2017%2F05%2F06%2F%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93_two%2F</url>
    <content type="text"><![CDATA[List 接口的大小可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。 （Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list.） 每个 ArrayList 实例都有一个容量。该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向 ArrayList 中不断添加元素，其容量也自动增长。 （Each ArrayList instance has a capacity. The capacity is the size of the array used to store the elements in the list. It is always at least as large as the list size. As elements are added to an ArrayList, its capacity grows automatically. ） ArrayList优、缺点分析优点： 线性有序存储，可重复存储 ArrayList是一种动态数组，首先在构造一个实例的时候，构造方法会给实例一个初始大小，当元素长度不够时，调用Arrays.copyOf方法，拷贝当前数组到一个新的长度更大的数组 查找快且方便，查找某数据时通过下标直接获取元素 缺点： 插入、增添、删除元素速率较低 线程不安全（Vector是线程安全的，但是效率不如ArrayList） 基本实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MyArrayList &#123; private Object[] elementDate; private int size; public Object get(int index) &#123; if(index&lt;0 || index&gt;=size) &#123; try &#123; throw new Exception(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return elementDate[index]; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public int size() &#123; return size; &#125; public MyArrayList()&#123; this(10); //调用有参构造方法，初始化数组大小为10 &#125; public MyArrayList(int initialCapacity)&#123; if(initialCapacity&lt;0)&#123; try &#123; throw new Exception(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; elementDate = new Object[initialCapacity]; &#125; public void add(Object obj) &#123; if(size==elementDate.length) &#123; Object[] newArrayList = new Object[size*2+1]; //当数组达到上限，创建新的数组对象 //System.arraycopy(elementDate, 0, newArrayList, 0, elementDate.length); //使用arraycopy方法也没问题，代码更简洁 for(int i=0; i&lt;newArrayList.length; i++) &#123; newArrayList[i] = elementDate[i]; //遍历旧数组元素，存入新数组 elementDate = newArrayList; //将新数组地址传递给旧数组 &#125; &#125; elementDate[size++] = obj; &#125; 对于remove方法的详细说明 remove方法可以根据索引值（index）或者指定对象删除元素： 123456public void remove(int index) &#123; rangeCheck(index); elementDate[index] = null; System.arraycopy(elementDate, index+1, elementDate, index, elementDate.length-(index+1)); size--; &#125; 当出现索引越界时，调用方法rangeCheck，代码： 123456789public void rangeCheck(int index) &#123; if(index &lt; 0 || index &gt;= this.size) &#123; try &#123; throw new Exception(); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; remove方法还有个重载（override）方法： 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); //fastRemove方法类似于索引删除方法 return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; //此处用的equals方法，为对象的值比较 fastRemove(index); return true; //这里return后返回boolean，所以只会删除第一次出现的对象 &#125; &#125; return false; &#125; remove方法的测试结果： 1234567891011public static void main(String[] args) &#123; ArrayList list = new ArrayList(); list.add("aa"); list.add("bb"); list.add(new Date()); list.add(new Date()); list.remove(new Date()); for(int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; &#125;]]></content>
      <categories>
        <category>DATA STRUCTURES</category>
      </categories>
      <tags>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡算法的逻辑分析]]></title>
    <url>%2F2017%2F05%2F06%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[在给定的一个数据中，我们有时候需要将数据对象进行某种顺序排列，常见的排列方式为升序或是降序，冒泡算法是处理这类排序的经典方法。 给定一个数组 1int[] arr = &#123;9,8,7,6,5&#125;; 要将这个降序数组重排为升序数组，我们可以通过： 将9和8进行比较，较大者和较小者换位–&gt;{8,9,7,6,5} 将9和7进行比较，较大者和较小者换位–&gt;{8,7,9,6,5} … 最终得到{8,7,6,5,9} 基本实现:123456789int[] arr = &#123; 9, 8, 7, 6, 5 &#125;; for (int i = 0; i &lt; arr.length - 1; i++) &#123; if (arr[i] &gt; arr[i + 1]) &#123; int temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; &#125; &#125; 之后，需要开始第二轮的排序，自然想到使用嵌套for循环来实现： 1234567891011int[] arr = &#123; 9, 8, 7, 6, 5 &#125;; for (int j = 0; j &lt; arr.length - 1; j++) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; if (arr[i] &gt; arr[i + 1]) &#123; int temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; &#125; &#125; &#125; 这时，我们会发现在遍历过程中，每一次遍历都会增加一次不必要的重复比较，具体逻辑分析过程可以列举每一次的两个数字比较发现。因此在第二次for循环中，随着遍历的递进，都需要减少1次arr.length,实际上可以在内部for循环中将循环条件改为arr.length-1 —&gt; arr.length-(1+j): 1234567891011int[] arr = &#123; 9, 8, 7, 6, 5 &#125;; for (int j = 0; j &lt; arr.length - 1; j++) &#123; for (int i = 0; i &lt; arr.length - (1 + j); i++) &#123; if (arr[i] &gt; arr[i + 1]) &#123; int temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; &#125; &#125; &#125; 现在，这个排序算法已经很好了，但是还可以继续优化,如果我们遇到仅需要一次排序就可以完成的数组，如:{9，5，6，7，8}，我们可以通过加入if和boolean来升级当前排序： 最终效果:12345678910111213141516int[] arr = &#123; 9,5,6,7,8 &#125;; boolean b = true; for (int j = 0; j &lt; arr.length - 1; j++) &#123; b = false; for (int i = 0; i &lt; arr.length - 1 - j; i++) &#123; if (arr[i] &gt; arr[i + 1]) &#123; int temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; b = true; System.out.println(Arrays.toString(arr)); &#125; &#125; if(b == false) break; &#125; 最简单的排序算法,但是很实用!!!]]></content>
      <categories>
        <category>ALGORITHMS</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用容器（Collection）实现类总结（零）]]></title>
    <url>%2F2017%2F05%2F06%2F%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93_one%2F</url>
    <content type="text"><![CDATA[容器（Collection） 层次结构中的根（root）接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何直接 实现：它提供更具体的子接口（如 Set 和 List）实现。此接口通常用来传递 collection，并在需要最大普遍性的地方操作这些 collection。 （The root interface in the collection hierarchy. A collection represents a group of objects, known as its elements. Some collections allow duplicate elements and others do not. Some are ordered and others unordered. The JDK does not provide any direct implementations of this interface: it provides implementations of more specific subinterfaces like Set and List. This interface is typically used to pass collections around and manipulate them where maximum generality is desired.） 其中，常用的具体类有： ArrayList：底层实现为数组（Array），可以重复放置元素，且为线性排列。优点是查找方便，缺点是增、删速率低。 LinkedList：底层实现为链表（Link list），优点是删除和添加的效率很高，但随机访问元素时效率较ArrayList类低。 HashMap：通过键值对（Key—Value）映射的数据结构（类似于字典的用法），且Key有且唯一，但是一个Key可以一对多个Value，细节后续讨论。优点是可以通过Key快速查找并操作相关数据，很方便。 HashSet：不允许重复的对象传入，且不能保证传入数据能够有序迭代（ It makes no guarantees as to the iteration order of the set）。优点是HashSet利用Hash函数进行了查询效率上的优化。]]></content>
      <categories>
        <category>DATA STRUCTURES</category>
      </categories>
      <tags>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器小结]]></title>
    <url>%2F2017%2F05%2F06%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[为什么使用迭代器? 数组的遍历，可以通过for循环来实现，其原因是数组对于数据的储存是有序的(order)；但是，对于Set这种无序(no order) 的数据结构，就无法通过for循环来实现，此时，我们就需要引入一种新的访问方式来实现对数据的操作——迭代器。 迭代器是一种轻量级的对象操作，其接口有四个抽象方法： 12345678910111213public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); default void remove() &#123; throw new UnsupportedOperationException("remove"); &#125; default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next()); &#125;&#125; 方法简介: –Object next()：返回集合里下一个元素。 –boolean hasNext()：如果被迭代的集合还元素没有被遍历，则返回true。 –void remove() ：删除集合里上一次next方法返回的元素 –void forEachRemaining(Consumer action)，这是Java 8为Iterator新增的默认方法，该方法可使用Lambda表达式来遍历集合元素。 迭代器的内部简单实现：12345678910111213141516171819202122public class SimpleIter &#123; private int size =elem.length; private int coursor=-1; //由实现的方法可知，游标在开始遍历List的时候从下标【0】开始，所以初始值赋予-1 public int size()&#123; return this.size; &#125; public boolean hasNext()&#123; return coursor+1&lt;size; //为了防止下标越界，所以coursor+1小于List长度 &#125; public String next()&#123; coursor++; return elem[coursor]; &#125; public void remove()&#123; System.arraycopy(elem, coursor+1, elem, coursor,this.size-(coursor+1)); this.size--; this.coursor--; //为了使游标可以指向删除某元素之后的正确指向，每次删除元素，需要coursor-1 &#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>