<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>I&#39;m NOthing</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-06T17:06:01.395Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Allen Gu</name>
    <email>guhaotian0712@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>win10_java_环境变量设置</title>
    <link href="http://yoursite.com/2017/05/06/win10_java_%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/05/06/win10_java_环境变量设置/</id>
    <published>2017-05-06T12:34:00.844Z</published>
    <updated>2017-05-06T17:06:01.395Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><link rel="stylesheet" type="text/css" href="/css/lib/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>竟然忘了java环境变量怎么配了…丢人<br>写下笔记</p>
<blockquote>
<p>下载<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external">java开发工具包</a>.</p>
</blockquote>
<p>直接打开系统<br><a id="more"></a><br>之后打开:<br><img src="1.jpg" alt="loading~~~"></p>
<p>点击环境变量:<br><img src="2.jpg" alt="loading~~~"></p>
<p>点击系统变量的新建:<br><img src="3.jpg" alt="loading~~~"></p>
<p>变量值就是下载后的jdk路径:<br><img src="4.jpg" alt="loading~~~"></p>
<blockquote>
<p>最后打开Path,点击新建,引入”C:\Program Files\Java\jdk1.8.0_112\bin”,”%JAVA_HOME%bin”</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;竟然忘了java环境变量怎么配了…丢人&lt;br&gt;写下笔记&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下载&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;java开发工具包&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直接打开系统&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java异常处理(Exception handing)机制</title>
    <link href="http://yoursite.com/2017/05/06/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2017/05/06/异常处理/</id>
    <published>2017-05-06T10:42:45.928Z</published>
    <updated>2017-05-06T12:32:27.545Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><link rel="stylesheet" type="text/css" href="/css/lib/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><blockquote>
<p>异常对象都是派生于throwable类的实例:</p>
</blockquote>
<p><img src="1.jpg" alt="loading~~~"></p>
<ul>
<li>Error类说明java运行时存在内存错误或资源耗尽错误,出现这类错误,除了告诉用户,别无他法</li>
<li>Exception是需要关注的;它又分为RuntimeException和IOException</li>
</ul>
<p><strong>如果出现了RuntimeException,那么一定是你自己的问题</strong></p>
<p>Error类或RuntimeException类的所有异常称为非受查(uncheck)异常,其他的异常成为受查(check)异常</p>
<h3 id="受查异常"><a href="#受查异常" class="headerlink" title="受查异常"></a>受查异常</h3><blockquote>
<p>需要记住在以下情况中应该抛出异常:</p>
</blockquote>
<ul>
<li>调用一个抛出受查异常的方法时,如:FileInputSteam构造器</li>
<li>程序运行时发现错误,利用throw抛出一个受查异常</li>
<li>程序出现错误时,如:数组越界(ArrayIndexOutOfBoundsException)</li>
<li>java虚拟机和运行时库内出现的内部错误<a id="more"></a>
</li>
</ul>
<p>如果出现前两种异常之一,则必须告诉程序员调用这个方法可能会出现的异常,如果没有处理器捕获,当前执行的线程就会结束</p>
<p>对于可能被其他人调用的方法,应根据异常规范(exception specification),在方法首部声明者个可能的的异常:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAnimation</span></span></div><div class="line">&#123;</div><div class="line">    . . .</div><div class="line">    public Image loadImage(String s) throws IOException</div><div class="line">    &#123;</div><div class="line">        . . .</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是,无需声明java的内部错误,我们无法控制Error.</p>
<p>同样,不应该声明从RuntimeException继承的非受查异常:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAnimation</span></span></div><div class="line">&#123;</div><div class="line">    . . .</div><div class="line">    void drawImage(int i) throws ArrayIndexOutOfBoundsException</div><div class="line">    &#123;</div><div class="line">        . . .</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些异常完全在我们的控制之下,与其去说明异常,我们更应该将精力花费在修改程序上</p>
<p><strong>总之,一个方法必须声明可能抛出的受查异常,非受查异常要么是错误(Error),要么是可以避免发生的RuntimeException</strong></p>
<p><strong>注意:</strong></p>
<ul>
<li>如果在子类中覆盖了一个父类的方法,子类声明的受查异常不可比父类的方法中声明的异常更为通用.</li>
<li>如果父类方法没有抛出任何受查异常,那么子类也不能抛出任何受查异常</li>
</ul>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><blockquote>
<p>对于一个已知的异常类:</p>
</blockquote>
<ol>
<li><p>找到一个合适的异常类</p>
</li>
<li><p>创建这个类的对象</p>
</li>
<li><p>将对象抛出</p>
</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">String readData(Scanner <span class="keyword">in</span>) throws EOFException</div><div class="line">&#123;</div><div class="line">    . . .</div><div class="line">    <span class="keyword">while</span> (. . .)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">in</span>.hasNext())</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (n &lt; len)</div><div class="line">            throw new EOFException();</div><div class="line">        &#125;</div><div class="line">        . . .</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一旦方法抛出了异常,该方法就不会返回给调用者,我们就不必再为返回的默认值或错误代码担忧　　</p>
<h3 id="创建异常"><a href="#创建异常" class="headerlink" title="创建异常"></a>创建异常</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileFormatException</span> <span class="title">extends</span> <span class="title">IOException</span></span></div><div class="line">&#123;</div><div class="line">    public FileFormatException() &#123;&#125;</div><div class="line">    public FileFormatException(String gripe)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">super</span>(gripe);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>习惯上,定义的类包含两个构造器,一个是无参构造器,另一个是带有详细描述的构造器(父类Throwable的toString方法将会打印出详细信息)　</p>
<blockquote>
<p>自定义构造器代码例:</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">String readData(BufferedReader <span class="keyword">in</span>) throws FileFormatException</div><div class="line">&#123;</div><div class="line">    . . .</div><div class="line">    <span class="keyword">while</span> (. . .)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (ch == -<span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (n &lt; len)</div><div class="line">            throw new FileFormatException();</div><div class="line">        &#125;</div><div class="line">        . . .</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">try</div><div class="line">&#123;</div><div class="line">    code</div><div class="line">    more code</div><div class="line">    more code</div><div class="line">&#125;</div><div class="line">catch (ExceptionType e)</div><div class="line">&#123;</div><div class="line">    handler <span class="keyword">for</span> this type</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>如果在try语句块中抛出了在catch语句块中说明的异常类,那么:</p>
</blockquote>
<ul>
<li>程序将跳过try语句块其余的代码</li>
<li>执行catch子句中的处理代码(如果在try中没有抛出任何异常,跳过catch子句)</li>
</ul>
<p><strong>如果方法中任何代码抛出了在catch中没有声明的异常,那么这个方法会立即退出</strong></p>
<blockquote>
<p>代码说明:</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void read(String filename)</div><div class="line">&#123;</div><div class="line">    try</div><div class="line">    &#123;   </div><div class="line">   　　 InputStream <span class="keyword">in</span> = new FileInputStream(filename);</div><div class="line">   　　 int b;</div><div class="line">   　　 <span class="keyword">while</span> ((b = <span class="keyword">in</span>.read()) != -<span class="number">1</span>)</div><div class="line">    　　&#123;</div><div class="line">        　　process input</div><div class="line">   　　 &#125;</div><div class="line">　　&#125;</div><div class="line">　　catch (IOException exception)</div><div class="line">    &#123;</div><div class="line">        exception.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>read方法可能抛出一个IOException,这将会跳出while循环,进入catch子句,并声称一个栈轨迹(stack trace)</p>
<p>通常,最好的办法是什么也不做,而是将异常传给调用者,让调用者去操心怎么做,如果采用这种方式,就必须声明这个方法可能会抛出的异常:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void read(String filename) throws IOException</div></pre></td></tr></table></figure>
<h4 id="捕获多异常"><a href="#捕获多异常" class="headerlink" title="捕获多异常"></a>捕获多异常</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">try</div><div class="line">&#123;</div><div class="line">    code that might throw exceptions</div><div class="line">&#125;</div><div class="line">catch (FileNotFoundException e)</div><div class="line">&#123;</div><div class="line">    emergency action <span class="keyword">for</span> missing files</div><div class="line">&#125;</div><div class="line">catch (UnknownHostException e)</div><div class="line">&#123;</div><div class="line">    emergency action <span class="keyword">for</span> unknown hosts</div><div class="line">&#125;</div><div class="line">catch (IOException e)</div><div class="line">&#123;</div><div class="line">    emergency action <span class="keyword">for</span> all other I/O problems</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在JKD1.7之后,可以这样捕获异常:</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">catch (FileNotFoundException <span class="params">| UnknownHostException e)</span></div><div class="line">&#123;</div><div class="line">    emergency action <span class="keyword">for</span> missing files <span class="keyword">and</span> unknown hosts</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意:捕获多个异常时,异常的变量为final</strong></p>
<p>捕获多个异常不仅会使代码看起来更简洁,而且会使代码运行效率更快</p>
<h3 id="finally语句"><a href="#finally语句" class="headerlink" title="finally语句"></a>finally语句</h3><blockquote>
<p>不管是否有异常被捕获,finally子句都必将被执行:</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">InputStream in = new FileInputStream(. . .);</div><div class="line">try</div><div class="line">&#123;</div><div class="line">    // 1</div><div class="line">    code that might throw exceptions</div><div class="line">    // 2</div><div class="line">&#125;</div><div class="line">catch (IOException e)</div><div class="line">&#123;</div><div class="line">    // 3</div><div class="line">    show error message</div><div class="line">    // 4</div><div class="line">&#125;</div><div class="line">finally</div><div class="line">&#123;</div><div class="line">    // 5</div><div class="line">    in.close();</div><div class="line">&#125;</div><div class="line">// 6</div></pre></td></tr></table></figure>
<p>1).代码没有抛出异常.执行:1.2.5.6</p>
<p>2).抛出一个可以在catch中捕获的异常:</p>
<ul>
<li>如果catch没有抛出异常,执行:1.3.4.5.6</li>
<li>如果catch子句抛出一个异常,执行:1.3.5(异常被抛会给方法调用者)</li>
</ul>
<p>3).代码抛出一个异常,但没有catch可以捕获到,执行:1.5</p>
<p>因此,<strong>finally子句是无论如何都会执行的</strong>,下面的例子会有令人意外的结果:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static int f(int n)</div><div class="line">&#123;</div><div class="line">    try</div><div class="line">    &#123;</div><div class="line">        int r = n * n;</div><div class="line">        <span class="keyword">return</span> r;</div><div class="line">    &#125;</div><div class="line">    finally</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用f(2),try子句return结果r = 4,但是finally必然执行,return 0并覆盖 r = 4.
　</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h2&gt;&lt;h4 id=&quot;异常分类&quot;&gt;&lt;a href=&quot;#异常分类&quot; class=&quot;headerlink&quot; title=&quot;异常分类&quot;&gt;&lt;/a&gt;异常分类&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;异常对象都是派生于throwable类的实例:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;1.jpg&quot; alt=&quot;loading~~~&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Error类说明java运行时存在内存错误或资源耗尽错误,出现这类错误,除了告诉用户,别无他法&lt;/li&gt;
&lt;li&gt;Exception是需要关注的;它又分为RuntimeException和IOException&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如果出现了RuntimeException,那么一定是你自己的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Error类或RuntimeException类的所有异常称为非受查(uncheck)异常,其他的异常成为受查(check)异常&lt;/p&gt;
&lt;h3 id=&quot;受查异常&quot;&gt;&lt;a href=&quot;#受查异常&quot; class=&quot;headerlink&quot; title=&quot;受查异常&quot;&gt;&lt;/a&gt;受查异常&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;需要记住在以下情况中应该抛出异常:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;调用一个抛出受查异常的方法时,如:FileInputSteam构造器&lt;/li&gt;
&lt;li&gt;程序运行时发现错误,利用throw抛出一个受查异常&lt;/li&gt;
&lt;li&gt;程序出现错误时,如:数组越界(ArrayIndexOutOfBoundsException)&lt;/li&gt;
&lt;li&gt;java虚拟机和运行时库内出现的内部错误
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>内部类总结</title>
    <link href="http://yoursite.com/2017/05/06/%E5%86%85%E9%83%A8%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/05/06/内部类总结/</id>
    <published>2017-05-06T10:32:23.239Z</published>
    <updated>2017-05-06T11:11:41.010Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><link rel="stylesheet" type="text/css" href="/css/lib/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><strong>内部类</strong>是java中比较复杂的内容,接下来进行一些细节总结:</p>
<blockquote>
<p>内部类(inner class)是定义在一个类中的类,这种技巧有什么好处呢?</p>
</blockquote>
<ul>
<li>内部类可以访问外部类中的数据,包括私有数据</li>
<li>内部类对于包中其它类来说是隐藏的</li>
<li>当想要定义一个<em>回调(callback)函数</em>时,可以使用匿名内部类,这样更为便捷<br>　　(回调函数:可以指出一个特定事件发生时应该采取的动作.例如在按下鼠标或选择某个菜单时应该采取什么行动)<a id="more"></a>
</li>
</ul>
<h3 id="使用内部类访问对象状态"><a href="#使用内部类访问对象状态" class="headerlink" title="使用内部类访问对象状态"></a>使用内部类访问对象状态</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TalkingClock</span></span></div><div class="line">&#123;</div><div class="line">    private int interval;</div><div class="line">    private boolean beep;</div><div class="line"></div><div class="line">    public TalkingClock(int interval, boolean beep) &#123; . . . &#125;</div><div class="line">    public void start() &#123; . . . &#125;</div><div class="line"></div><div class="line">    public <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="title">implements</span> <span class="title">ActionListener</span> //内部类</span></div><div class="line"></div><div class="line">    &#123;</div><div class="line">        . . .</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>内部类的详细代码:</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="title">implements</span> <span class="title">ActionListener</span></span></div><div class="line">&#123;</div><div class="line">    public void actionPerformed(ActionEvent event)</div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"At the tone, the time is "</span> + new Date());</div><div class="line">        <span class="keyword">if</span> (beep) Toolkit.getDefaultToolkit().beep();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现,在内部类中的beep是外部类中的变量,这样的引用是如何做到的呢?</p>
<p>事实上,是通过这样一种方式调用的:   </p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (outer.beep) Toolkit.getDefaultToolkit().beep();</div></pre></td></tr></table></figure>
<blockquote>
<p>但是,outer并不是java中的关键字,可以看到,内部类并没有构造器,所以编译器隐式地给内部类了一个构造器:</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public TimePrinter(TalkingClock clock)</div><div class="line">&#123;</div><div class="line">    outer = clock;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="内部类的特殊语法规则"><a href="#内部类的特殊语法规则" class="headerlink" title="内部类的特殊语法规则"></a>内部类的特殊语法规则</h3><blockquote>
<p>内部类对外部类引用的语法还要复杂一点:outerclass.this表示外部类数据的引用,如:</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="title">implements</span> <span class="title">ActionListener</span></span></div><div class="line">&#123;</div><div class="line">    public void actionPerformed(ActionEvent event)</div><div class="line">    &#123;</div><div class="line">        System.out.println(<span class="string">"At the tone, the time is "</span> + new Date());</div><div class="line">        <span class="keyword">if</span> (outer.this.beep) Toolkit.getDefaultToolkit().beep();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>细节规则:</p>
<ul>
<li>内部类中所有的静态域都必须是final,因为对于一个外部类的实例,我们希望它都只有唯一一个内部类实例</li>
<li>内部类不能有静态方法</li>
</ul>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><blockquote>
<p>如果内部类只在外部类的一个方法中调用了一次,我们可以采取使用局部内部类来简化代码:</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void start()</div><div class="line">&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TimePrinter</span> <span class="title">implements</span> <span class="title">ActionListener</span></span></div><div class="line">    &#123;</div><div class="line">        public void actionPerformed(ActionEvent event)</div><div class="line">        &#123;</div><div class="line">            System.out.println(<span class="string">"At the tone, the time is "</span> + new Date());</div><div class="line">            <span class="keyword">if</span> (beep) Toolkit.getDefaultToolkit().beep();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ActionListener listener = new TimePrinter();</div><div class="line">    Timer t = new Timer(interval, listener);</div><div class="line">    t.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>局部内部类不能用public和private来声明,它的作用域只限于在这个局部的块中<br>局部内部类的另一个优点是对外部世界完全隐蔽,即除了start()方法外,没有任何方法知道TimePrinter类</p>
<p>细节规则:</p>
</blockquote>
<p>当局部内部类访问局部变量时,必须为final</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int counter = <span class="number">0</span>;</div><div class="line">Date[] dates = new Date[<span class="number">100</span>];</div><div class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; dates.length; i++)</div><div class="line">    dates[i] = new Date()</div><div class="line">        &#123;</div><div class="line">            public int compareTo(Date other)</div><div class="line">            &#123;</div><div class="line">                counter++; <span class="regexp">//</span>错误</div><div class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.compareTo(other);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">Arrays.sort(dates);</div><div class="line">System.out.println(counter + <span class="string">" comparisons."</span>);</div></pre></td></tr></table></figure>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void start(int interval, boolean beep)</div><div class="line">&#123;</div><div class="line">    ActionListener listener = new ActionListener()</div><div class="line">    &#123;</div><div class="line">        public void actionPerformed(ActionEvent event)</div><div class="line">        &#123;</div><div class="line">            System.out.println(<span class="string">"At the tone, the time is "</span> + new Date());</div><div class="line">            <span class="keyword">if</span> (beep) Toolkit.getDefaultToolkit().beep();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    Timer t = new Timer(interval, listener);</div><div class="line">    t.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>细节规则:</p>
</blockquote>
<p>由于构造器的名字必须与类相同,但是匿名内部类没有名字,所以匿名内部类没有构造器</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;内部类&lt;/strong&gt;是java中比较复杂的内容,接下来进行一些细节总结:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;内部类(inner class)是定义在一个类中的类,这种技巧有什么好处呢?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;内部类可以访问外部类中的数据,包括私有数据&lt;/li&gt;
&lt;li&gt;内部类对于包中其它类来说是隐藏的&lt;/li&gt;
&lt;li&gt;当想要定义一个&lt;em&gt;回调(callback)函数&lt;/em&gt;时,可以使用匿名内部类,这样更为便捷&lt;br&gt;　　(回调函数:可以指出一个特定事件发生时应该采取的动作.例如在按下鼠标或选择某个菜单时应该采取什么行动)
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>类的设计技巧简单总结</title>
    <link href="http://yoursite.com/2017/05/06/%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/05/06/类的设计技巧简单总结/</id>
    <published>2017-05-06T10:28:32.945Z</published>
    <updated>2017-05-06T11:12:40.898Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><link rel="stylesheet" type="text/css" href="/css/lib/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>保证数据的私有性(private):</p>
</blockquote>
<p>为了实现一个类的良好封装性,一定不要使用其他的方式去声明成员变量,这是为了后期代码维护做的基本准备.</p>
<blockquote>
<p>对数据初始化:</p>
</blockquote>
<p>虽然编译器会自动对成员变量进行隐式初始化,但是为了可读性,应该为变量提供初始化或是利用构造器进行初始化(局部变量必须初始化).</p>
<blockquote>
<p>不要在类中使用过多的基本类型:</p>
</blockquote>
<p>意思是当类中存在多个基本数据类型时,用一个引用类型来包装这些基本类型,这样可以增强其可读性,且后期要替换这个类的名称也更简单.<br><a id="more"></a></p>
<blockquote>
<p>并非所有的域都需要getter/setter:</p>
</blockquote>
<p>例如:在一个Employee类中,雇员的薪水是可以有getter和setter的,但是雇员的雇佣日期就不应该有setter.</p>
<blockquote>
<p>一个类的功能尽量不要太繁杂:</p>
</blockquote>
<p>如果一个类的某些功能明显的可以分为两类,就应该将其分解.</p>
<blockquote>
<p>类名/方法名的名称要可以体现其职责</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;保证数据的私有性(private):&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了实现一个类的良好封装性,一定不要使用其他的方式去声明成员变量,这是为了后期代码维护做的基本准备.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对数据初始化:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然编译器会自动对成员变量进行隐式初始化,但是为了可读性,应该为变量提供初始化或是利用构造器进行初始化(局部变量必须初始化).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不要在类中使用过多的基本类型:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意思是当类中存在多个基本数据类型时,用一个引用类型来包装这些基本类型,这样可以增强其可读性,且后期要替换这个类的名称也更简单.&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>用java写一个简单的文件拷贝程序吧</title>
    <link href="http://yoursite.com/2017/05/06/%E7%94%A8java%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E7%A8%8B%E5%BA%8F%E5%90%A7/"/>
    <id>http://yoursite.com/2017/05/06/用java写一个简单的文件拷贝程序吧/</id>
    <published>2017-05-06T10:26:30.178Z</published>
    <updated>2017-05-06T10:27:39.403Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><link rel="stylesheet" type="text/css" href="/css/lib/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>代码:</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public static void copyFile(String srcPath, String destPath) throws IOException &#123;</div><div class="line">        //建立File对象的来源与目的</div><div class="line">        File src = new File(srcPath);</div><div class="line">        File dest = new File(destPath);</div><div class="line">        </div><div class="line">        //由于只能拷贝文件,所以判定输入流是否为文件</div><div class="line">        if(!src.isFile()) &#123;</div><div class="line">            System.out.println("只能拷贝文件!");</div><div class="line">            throw new IOException("只能拷贝文件!");</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //文件输入输出</div><div class="line">        InputStream is = new FileInputStream(src);</div><div class="line">        OutputStream os = new FileOutputStream(dest);</div><div class="line">        </div><div class="line">        //读取文件大小,并循环写出文件</div><div class="line">        byte[] flush = new byte[1024];</div><div class="line">        int len = 0;</div><div class="line">        while(-1 != (len = is.read(flush))) &#123;</div><div class="line">            os.write(flush, 0, len);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //刷新此输出流并强制写出所有缓冲的输出字节</div><div class="line">        os.flush();</div><div class="line">        </div><div class="line">        //释放资源(一般先打开的后关闭)</div><div class="line">        os.close();</div><div class="line">        is.close();</div><div class="line">        </div><div class="line">        System.out.println("拷贝成功!");</div><div class="line">    &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/lib/hint.min.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java中引用传递和值传递的理解</title>
    <link href="http://yoursite.com/2017/05/06/java%E4%B8%AD%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8C%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/05/06/java中引用传递和值传递的理解/</id>
    <published>2017-05-06T10:14:51.329Z</published>
    <updated>2017-05-06T11:13:17.344Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><link rel="stylesheet" type="text/css" href="/css/lib/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>按值调用(call by value):表示方法接收的是调用者提供的值<br>按引用调用(call by reference):表示方法接收的是调用者提供的地址</p>
</blockquote>
<p>一个方法可以修改<strong>引用传递</strong>所对应的变量值,而不能修改<strong>值传递</strong>调用所对应的变量值</p>
<p><strong>对于java来说,是不存在引用传递的,它总是按值调用</strong></p>
<p>如何理解?方法是得到所有参数值的一个拷贝,<em>方法无法修改传递给它的任何变量值的内容</em><br><a id="more"></a></p>
<blockquote>
<p>示例1:</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">        int temp = <span class="number">0</span>;</div><div class="line">        int x = <span class="number">10</span>;</div><div class="line">        int y = <span class="number">11</span>;</div><div class="line">        System.out.println(<span class="string">"before: "</span> + x + <span class="string">" "</span>+ y); <span class="regexp">//</span> x = <span class="number">10</span>, y = <span class="number">11</span></div><div class="line">        temp = y;</div><div class="line">        y = x;</div><div class="line">        x = temp;</div><div class="line">        System.out.println(<span class="string">"after: "</span> + x + <span class="string">" "</span>+ y);  <span class="regexp">//</span> x = <span class="number">11</span>, y = <span class="number">10</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>示例2:</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">        int temp = <span class="number">0</span>;</div><div class="line">        int x = <span class="number">10</span>;</div><div class="line">        int y = <span class="number">11</span>;</div><div class="line">        System.out.println(<span class="string">"before: "</span> + x + <span class="string">" "</span>+ y); <span class="regexp">//</span> x = <span class="number">10</span>, y = <span class="number">11</span></div><div class="line">        change(x, y);</div><div class="line">        System.out.println(<span class="string">"after: "</span> + x + <span class="string">" "</span>+ y);   <span class="regexp">//</span> x = <span class="number">10</span>, y = <span class="number">11</span> </div><div class="line">    &#125;</div><div class="line">    public static void change(int x, int y) &#123;</div><div class="line">        int temp = <span class="number">0</span>;</div><div class="line">        temp = y;</div><div class="line">        y = x;</div><div class="line">        x = temp;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们可以看到,一个方法不可以改变<strong>基本数据类型</strong>参数值,但可以通过引用类型来改变参数:</p>
<blockquote>
<p>示例3:</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">        Test t1 = new Test(<span class="string">"James"</span>, <span class="number">15</span>);</div><div class="line">        </div><div class="line">        plus(t1);</div><div class="line">        </div><div class="line">        System.out.println(t1.age); <span class="regexp">//</span> 输出<span class="number">25</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static void plus(Test t)&#123;</div><div class="line">        t.age += <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></div><div class="line">    String name;</div><div class="line">    int age;</div><div class="line">    </div><div class="line">    public Test(String name, int age) &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>最后,我们来试验一下引用类型是否可以对象交换:</p>
<blockquote>
<p>示例4:</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">        Test t1 = new Test(<span class="string">"James"</span>, <span class="number">15</span>);</div><div class="line">        Test t2 = new Test(<span class="string">"Alice"</span>, <span class="number">20</span>);</div><div class="line">        System.out.println(t1 + <span class="string">" "</span> + t2); <span class="regexp">//t</span>1 = test.Test@15db9742, t2 = test.Test@6d06d69c</div><div class="line">        swap(t1, t2);</div><div class="line">        System.out.println(t1 + <span class="string">" "</span> + t2);  <span class="regexp">//t</span>1 = test.Test@15db9742, t2 = test.Test@6d06d69c</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static void swap(Test t1, Test t2) &#123;</div><div class="line">        Test temp = t1;</div><div class="line">        t2 = t1;</div><div class="line">        t1 = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></div><div class="line">    String name;</div><div class="line">    int age;</div><div class="line">    </div><div class="line">    public Test(String name, int age) &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public Integer plus(Integer age)&#123;</div><div class="line">        age += <span class="number">10</span>;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>依旧是无法实现的</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;按值调用(call by value):表示方法接收的是调用者提供的值&lt;br&gt;按引用调用(call by reference):表示方法接收的是调用者提供的地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个方法可以修改&lt;strong&gt;引用传递&lt;/strong&gt;所对应的变量值,而不能修改&lt;strong&gt;值传递&lt;/strong&gt;调用所对应的变量值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于java来说,是不存在引用传递的,它总是按值调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如何理解?方法是得到所有参数值的一个拷贝,&lt;em&gt;方法无法修改传递给它的任何变量值的内容&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>常用容器（Collection）实现类总结（四）——HashSet</title>
    <link href="http://yoursite.com/2017/05/06/%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93-five/"/>
    <id>http://yoursite.com/2017/05/06/常用容器总结-five/</id>
    <published>2017-05-06T10:07:49.232Z</published>
    <updated>2017-05-06T11:14:00.340Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><link rel="stylesheet" type="text/css" href="/css/lib/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><em>此类实现 Set 接口，由哈希表（实际上是一个 HashMap 实例）支持。它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用 null 元素。</em></p>
<p>(This class implements the Set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the null element. )</p>
<p><strong>(注意:HashSet必须重写hashcode和equals方法)</strong></p>
<a id="more"></a>
<h3 id="HashSet的优、缺点分析"><a href="#HashSet的优、缺点分析" class="headerlink" title="HashSet的优、缺点分析"></a>HashSet的优、缺点分析</h3><p>优点：</p>
<ul>
<li>不允许储存相同的对象(注意:HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false)</li>
</ul>
<p>缺点：</p>
<ul>
<li>相较HashMap速度慢(HashMap由唯一的Key来找Value)</li>
</ul>
<h3 id="方法分析"><a href="#方法分析" class="headerlink" title="方法分析"></a>方法分析</h3><blockquote>
<p>HashSet的底层实现实际上是HashMap,主要分析其中一个方法add():</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean add(E e) &#123;</div><div class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见,传入的形参e是作为map的Key,<strong>而HashSet的元素不可重复实际上就是利用了Map中Key的不可重复</strong></p>
<blockquote>
<p>再看看PRESENT是什么:</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private static final Object PRESENT = new Object();</div></pre></td></tr></table></figure>
<p>定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;此类实现 Set 接口，由哈希表（实际上是一个 HashMap 实例）支持。它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用 null 元素。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;(This class implements the Set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the null element. )&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(注意:HashSet必须重写hashcode和equals方法)&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DATA STRUCTURES" scheme="http://yoursite.com/categories/DATA-STRUCTURES/"/>
    
    
      <category term="Data Structures" scheme="http://yoursite.com/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>常用容器（Collection）实现类总结（三）——HashMap</title>
    <link href="http://yoursite.com/2017/05/06/%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93_four/"/>
    <id>http://yoursite.com/2017/05/06/常用容器总结_four/</id>
    <published>2017-05-06T09:55:30.318Z</published>
    <updated>2017-05-07T07:36:22.964Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><link rel="stylesheet" type="text/css" href="/css/lib/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><em>基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</em></p>
<p>(Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.  )</p>
<p><em>此实现假定哈希函数将元素适当地分布在各桶(buckets)之间，可为基本操作（get 和 put）提供稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。</em> </p>
<p>(This implementation provides constant-time performance for the basic operations (get and put), assuming the hash function disperses the elements properly among the buckets. Iteration over collection views requires time proportional to the “capacity” of the HashMap instance (the number of buckets) plus its size (the number of key-value mappings). Thus, it’s very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important. )</p>
<a id="more"></a>
<h3 id="HashMap的优、缺点分析"><a href="#HashMap的优、缺点分析" class="headerlink" title="HashMap的优、缺点分析"></a>HashMap的优、缺点分析</h3><p>优点：</p>
<ul>
<li>通过键值对(key-value)而构成一对一（也可以是一对多）的映射关系，方便数据的查询</li>
<li>由于HashMap只允许唯一键的存在，所以查询速度较快</li>
</ul>
<p>缺点：</p>
<ul>
<li>映射无序，且不保证顺序恒定</li>
</ul>
<h3 id="HashMap基本实现"><a href="#HashMap基本实现" class="headerlink" title="HashMap基本实现"></a>HashMap基本实现</h3><blockquote>
<p>Entry类的实现：</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span> &#123;</span></div><div class="line">    Object key;</div><div class="line">    Object value;</div><div class="line">    </div><div class="line">    public Entry() &#123;&#125;</div><div class="line">    </div><div class="line">    public Entry(Object key, Object value) &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        this.key = key;</div><div class="line">        this.value = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HashMap操作的是键值对,需要一个Entry类来实现</p>
<blockquote>
<p>MyHashMap类的简单实现：</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">public class MyHashMap &#123;</div><div class="line">    Entry[] arr = new Entry[100];</div><div class="line">    int size;</div><div class="line">    </div><div class="line">    public void put(Object key, Object value) &#123;</div><div class="line">        Entry e = new Entry(key, value);</div><div class="line">        for(int i = 0;i &lt; size; i++) &#123;</div><div class="line">            if(arr[i].key.equals(key)) &#123;</div><div class="line">                arr[i].value = value;</div><div class="line">                return ;</div><div class="line">            &#125;</div><div class="line">        &#125;                            //由于HashMap只允许存在唯一键,重复的键值对会被新值覆盖,所以引入这段代码</div><div class="line">        arr[size++] = e;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public Object get(Object key) &#123;</div><div class="line">        for(int i = 0;i &lt; size; i++) &#123;</div><div class="line">            if(arr[i].key.equals(key)) &#123;</div><div class="line">                return arr[i].value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void remove(Object key) &#123;</div><div class="line">        for(int i = 0;i &lt; size; i++) &#123;</div><div class="line">            if(arr[i].key.equals(key)) &#123;</div><div class="line">                arr[i].value = null;</div><div class="line">                size--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public boolean containsKey(Object key) &#123;</div><div class="line">        for(int i = 0;i &lt; size; i++) &#123;</div><div class="line">            if(arr[i].key.equals(key)) &#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public boolean containsValue(Object value) &#123;</div><div class="line">        for(int i = 0;i &lt; size; i++) &#123;</div><div class="line">            if(arr[i].value.equals(value)) &#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public int getSize() &#123;</div><div class="line">        return size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setSize(int size) &#123;</div><div class="line">        this.size = size;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>显然,基本实现HashMap的方法效率低下,需要改进</p>
<h3 id="HashMap改进版"><a href="#HashMap改进版" class="headerlink" title="HashMap改进版"></a>HashMap改进版</h3><p>实际上,HashMap的底层实现是通过Array和LinkedList共同实现的,所以HashMap综合了两者的优点,实现的关键在于利用hashcode:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//存储时:</div><div class="line">int hash = key.hashCode();</div><div class="line">int index = hash % Entry[].length;</div><div class="line">Entry[index] = value;</div><div class="line"></div><div class="line">//取值时:</div><div class="line">int hash = key.hashCode();</div><div class="line">int index = hash % Entry[].length;</div><div class="line">return Entry[index];</div></pre></td></tr></table></figure>
<blockquote>
<p>HashMap实现的图片说明:</p>
</blockquote>
<p><img src="1.png" alt="loading~~~"></p>
<p><img src="2.jpg" alt="loading~~~"></p>
<blockquote>
<p>Entry类的升级:</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;K,<span class="title">V</span>&gt;&#123;</span></div><div class="line">    final K key;</div><div class="line">    V value;</div><div class="line">    Entry&lt;K,V&gt; <span class="keyword">next</span>;<span class="regexp">//</span>下一个结点</div><div class="line"> </div><div class="line">    public Entry(K key, V value, Entry&lt;K, V&gt; <span class="keyword">next</span>) &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        this.key = key;</div><div class="line">        this.value = value;</div><div class="line">        this.<span class="keyword">next</span> = <span class="keyword">next</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public final K getKey() &#123;</div><div class="line">        <span class="keyword">return</span> key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public final V getValue() &#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public final V setValue(V newValue) &#123;</div><div class="line">    V oldValue = value;</div><div class="line">        value = newValue;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>MyHashMap类的实现:</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">public class MyHashMap&lt;K, V&gt; &#123;</div><div class="line">    private Entry[] table;</div><div class="line">    static final int DEFAULT_INITIAL_CAPACITY = 16;//默认数组长度</div><div class="line">    private int size;</div><div class="line"></div><div class="line">    public Hash() &#123;</div><div class="line">        table = new Entry[DEFAULT_INITIAL_CAPACITY];</div><div class="line">        size = DEFAULT_INITIAL_CAPACITY;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getSize() &#123;</div><div class="line">        return size;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 求index</div><div class="line">    static int indexFor(int h, int length) &#123;</div><div class="line">        return h % (length - 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //获取value</div><div class="line">    public V get(Object key) &#123;</div><div class="line">        if (key == null)</div><div class="line">            return null;</div><div class="line">        int hash = key.hashCode();</div><div class="line">        int index = indexFor(hash, table.length);// 求key在数组中的下标</div><div class="line">        for (Entry&lt;K, V&gt; e = table[index]; e != null; e = e.next) &#123;</div><div class="line">            Object k = e.key;</div><div class="line">            if (e.key.hashCode() == hash &amp;&amp; (k == key || key.equals(k)))</div><div class="line">                return e.value;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public V put(K key, V value) &#123;</div><div class="line">        if (key == null)</div><div class="line">            return null;</div><div class="line">        int hash = key.hashCode();</div><div class="line">        int index = indexFor(hash, table.length);</div><div class="line"></div><div class="line">        for (Entry&lt;K, V&gt; e = table[index]; e != null; e = e.next) &#123;</div><div class="line">            Object k = e.key;</div><div class="line">            if (e.key.hashCode() == hash &amp;&amp; (k == key || key.equals(k))) &#123;</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = value;</div><div class="line">                return oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 如果key值不存在，那么需要添加</div><div class="line">        Entry&lt;K, V&gt; e = table[index];// 获取当前数组中的e</div><div class="line">        table[index] = new Entry&lt;K, V&gt;(key, value, e);// 新建一个Entry，并将其指向原先的e</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;(Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.  )&lt;/p&gt;
&lt;p&gt;&lt;em&gt;此实现假定哈希函数将元素适当地分布在各桶(buckets)之间，可为基本操作（get 和 put）提供稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;(This implementation provides constant-time performance for the basic operations (get and put), assuming the hash function disperses the elements properly among the buckets. Iteration over collection views requires time proportional to the “capacity” of the HashMap instance (the number of buckets) plus its size (the number of key-value mappings). Thus, it’s very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important. )&lt;/p&gt;
    
    </summary>
    
      <category term="DATA STRUCTURES" scheme="http://yoursite.com/categories/DATA-STRUCTURES/"/>
    
    
      <category term="Data Structures" scheme="http://yoursite.com/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>常用容器（Collection）实现类总结（二）——LinkedList</title>
    <link href="http://yoursite.com/2017/05/06/%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93-three/"/>
    <id>http://yoursite.com/2017/05/06/常用容器总结-three/</id>
    <published>2017-05-06T09:40:24.150Z</published>
    <updated>2017-05-06T09:54:52.432Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><link rel="stylesheet" type="text/css" href="/css/lib/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><em>List 接口的链接列表实现。实现所有可选的列表操作，并且允许所有元素（包括 null）。除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。</em></p>
<p>（Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null).All of the operations perform as could be expected for a doubly-linked list. Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index. ）</p>
<p><em>所有操作都是按照双重链接列表（doubly-linked list）的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。</em></p>
<p>（All of the operations perform as could be expected for a doubly-linked list. Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index. ）<br><a id="more"></a></p>
<h3 id="LinkedList的优、缺点分析"><a href="#LinkedList的优、缺点分析" class="headerlink" title="LinkedList的优、缺点分析"></a>LinkedList的优、缺点分析</h3><p>优点：</p>
<ul>
<li>操作的是数据指针，相对ArrayList大大增强了增、删速率</li>
</ul>
<p>缺点：</p>
<ul>
<li>查找速率较低</li>
<li>线程不安全</li>
</ul>
<blockquote>
<p>双向链表示意:</p>
</blockquote>
<p><img src="1.jpg" alt="loading~~~"></p>
<p><strong>链表与泛型集合有一个重要区别:链表是一个有序集合,每个对象的位置很重要.<br>LinkedList.add方法是将元素添加到列表的最后,但是有时我们需要在列表中插入一个元素,这时这时使用迭代器就很必要.</strong></p>
<blockquote>
<p>图例:</p>
</blockquote>
<p><img src="2.jpg" alt="loading~~~"></p>
<blockquote>
<p>相关代码:</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; staff = new LinkedList&lt;&gt;();</div><div class="line">staff.add(<span class="string">"Amy"</span>);</div><div class="line">staff.add(<span class="string">"Bob"</span>);</div><div class="line">staff.add(<span class="string">"Carl"</span>);</div><div class="line">ListIterator&lt;String&gt; iter = staff.listIterator();</div><div class="line">iter.<span class="keyword">next</span>(); <span class="regexp">//</span> skip past first element</div><div class="line">iter.add(<span class="string">"Juliet"</span>);</div></pre></td></tr></table></figure>
<p><strong>注意</strong>:<br>这里有个调用remove方法的小细节——迭代器的删除和backspace工作方式有区别,在调用了next后,remove确实是删除了迭代后左侧的元素,但是在调用了previous之后,remove的是迭代后右侧的元素,并且不能连续调用两次remove.</p>
<p>add只依赖于迭代器的位置,而remove注重迭代器的状态.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">        List&lt;String&gt; l = new LinkedList&lt;&gt;();</div><div class="line">        l.add(<span class="string">"a"</span>);</div><div class="line">        l.add(<span class="string">"b"</span>);</div><div class="line">        l.add(<span class="string">"c"</span>);</div><div class="line">        ListIterator&lt;String&gt; it = l.listIterator();</div><div class="line">        it.<span class="keyword">next</span>();</div><div class="line">        it.add(<span class="string">"some"</span>); <span class="regexp">//</span>在a后插入some</div><div class="line">        it.previous();</div><div class="line">        it.remove();</div><div class="line">        System.out.println(l);  <span class="regexp">//</span>输出[a, b, c],删除的是some而非a</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><blockquote>
<p><strong>Node类的实现</strong>：<br>由于在链表中，出现了节点（Node）的概念，所以我们先写如一个节点类，来操控指针：</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></div><div class="line">    private Node previous;</div><div class="line">    private Node <span class="keyword">next</span>;</div><div class="line">    private Object obj;</div><div class="line">    </div><div class="line">    public Node()&#123;&#125;</div><div class="line">    </div><div class="line">    public Node(Node previous, Node <span class="keyword">next</span>, Object obj) &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        this.previous = previous;</div><div class="line">        this.<span class="keyword">next</span> = <span class="keyword">next</span>;</div><div class="line">        this.obj = obj;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public Node getPrevious() &#123;</div><div class="line">        <span class="keyword">return</span> previous;</div><div class="line">    &#125;</div><div class="line">    public void setPrevious(Node previous) &#123;</div><div class="line">        this.previous = previous;</div><div class="line">    &#125;</div><div class="line">    public Node getNext() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">next</span>;</div><div class="line">    &#125;</div><div class="line">    public void setNext(Node <span class="keyword">next</span>) &#123;</div><div class="line">        this.<span class="keyword">next</span> = <span class="keyword">next</span>;</div><div class="line">    &#125;</div><div class="line">    public Object getObj() &#123;</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    &#125;</div><div class="line">    public void setObj(Object obj) &#123;</div><div class="line">        this.obj = obj;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们所实现的是双向链表，因此我定义了next和previous两个变量，顾名思义，目的就是为了对一个数据进行前后操作，后面定义了一系列getter/setter方法以达到增、删的操作；object变量显然就是储存的数据了</p>
<blockquote>
<p><strong>LinkedList类的实现</strong>：</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> &#123;</span></div><div class="line">    private Node first;</div><div class="line">    private Node last;</div><div class="line">    </div><div class="line">    private int size;</div><div class="line">    </div><div class="line">    public void add(Object obj) &#123;</div><div class="line">        Node n = new Node();</div><div class="line">        <span class="keyword">if</span>(first == null) &#123;</div><div class="line">            n.setPrevious(null);</div><div class="line">            n.setObj(obj);</div><div class="line">            n.setNext(null);</div><div class="line">            </div><div class="line">            first = n;</div><div class="line">            last = n;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            n.setPrevious(last);</div><div class="line">            n.setObj(obj);</div><div class="line">            n.setNext(null);</div><div class="line">            </div><div class="line">            last.setNext(n);</div><div class="line">            last = n;</div><div class="line">        &#125;</div><div class="line">        size++;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void add(int index, Object obj) &#123;</div><div class="line">        rangeCheck(index);</div><div class="line">        Node temp = (Node) find(index);</div><div class="line">        Node newNode = new Node();</div><div class="line">        Node prev = temp.getPrevious();</div><div class="line">        <span class="keyword">if</span>(temp != null) &#123;</div><div class="line">            newNode.setObj(obj);</div><div class="line">            prev.setNext(newNode);</div><div class="line">            newNode.setNext(temp);</div><div class="line">            newNode.setPrevious(prev);</div><div class="line">            temp.setPrevious(newNode);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void rangeCheck(int index) &#123;</div><div class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> <span class="params">||</span> index &gt;= this.size) &#123;   </div><div class="line">            try &#123;</div><div class="line">                throw new Exception();</div><div class="line">            &#125;catch(Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public Object get(int index) &#123;</div><div class="line">        rangeCheck(index);</div><div class="line">        Node temp = find(index);</div><div class="line">        <span class="keyword">if</span>(temp != null) &#123;</div><div class="line">            <span class="keyword">return</span> temp.getObj();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> null;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void remove(int index) &#123;</div><div class="line">        Node temp = find(index);</div><div class="line">        <span class="keyword">if</span> (temp != null) &#123;</div><div class="line">            Node prev = temp.getPrevious();</div><div class="line">            Node <span class="keyword">next</span> = temp.getNext();</div><div class="line">            prev.setNext(<span class="keyword">next</span>);</div><div class="line">            <span class="keyword">next</span>.setPrevious(prev);</div><div class="line">            size--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    public Node find(int index) &#123;</div><div class="line">        Node temp = first;</div><div class="line">        <span class="keyword">if</span>(first != null) &#123;</div><div class="line">            <span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; index; i++) &#123;</div><div class="line">                temp = first;</div><div class="line">                temp = temp.getNext();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> temp;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public int getSize() &#123;</div><div class="line">        <span class="keyword">return</span> size;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;List 接口的链接列表实现。实现所有可选的列表操作，并且允许所有元素（包括 null）。除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;（Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null).All of the operations perform as could be expected for a doubly-linked list. Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index. ）&lt;/p&gt;
&lt;p&gt;&lt;em&gt;所有操作都是按照双重链接列表（doubly-linked list）的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;（All of the operations perform as could be expected for a doubly-linked list. Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index. ）&lt;br&gt;
    
    </summary>
    
      <category term="DATA STRUCTURES" scheme="http://yoursite.com/categories/DATA-STRUCTURES/"/>
    
    
      <category term="Data Structures" scheme="http://yoursite.com/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>常用容器（Collection）实现类总结（一）——ArrayList</title>
    <link href="http://yoursite.com/2017/05/06/%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93_two/"/>
    <id>http://yoursite.com/2017/05/06/常用容器总结_two/</id>
    <published>2017-05-06T09:21:36.176Z</published>
    <updated>2017-05-06T09:37:32.700Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><link rel="stylesheet" type="text/css" href="/css/lib/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><em>List 接口的大小可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。</em></p>
<p>（Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list.）</p>
<p><em>每个 ArrayList 实例都有一个容量。该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向 ArrayList 中不断添加元素，其容量也自动增长。</em></p>
<p>（Each ArrayList instance has a capacity. The capacity is the size of the array used to store the elements in the list. It is always at least as large as the list size. As elements are added to an ArrayList, its capacity grows automatically. ）<br><a id="more"></a></p>
<h3 id="ArrayList优、缺点分析"><a href="#ArrayList优、缺点分析" class="headerlink" title="ArrayList优、缺点分析"></a>ArrayList优、缺点分析</h3><p>优点：</p>
<ul>
<li>线性有序存储，可重复存储</li>
<li>ArrayList是一种动态数组，首先在构造一个实例的时候，构造方法会给实例一个初始大小，当元素长度不够时，调用Arrays.copyOf方法，拷贝当前数组到一个新的长度更大的数组</li>
<li>查找快且方便，查找某数据时通过下标直接获取元素</li>
</ul>
<p>缺点：</p>
<ul>
<li>插入、增添、删除元素速率较低</li>
<li>线程不安全（Vector是线程安全的，但是效率不如ArrayList）</li>
</ul>
<h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public class MyArrayList &#123;</div><div class="line">    private Object[] elementDate;</div><div class="line">    </div><div class="line">    private int size;</div><div class="line">    </div><div class="line">    public Object get(int index) &#123;</div><div class="line">        if(index&lt;0 || index&gt;=size) &#123;</div><div class="line">            try &#123;</div><div class="line">                throw new Exception();</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return elementDate[index];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public boolean isEmpty() &#123;</div><div class="line">        return size == 0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public int size() &#123;</div><div class="line">        return size;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public MyArrayList()&#123;</div><div class="line">        this(10);          //调用有参构造方法，初始化数组大小为10</div><div class="line">    &#125;</div><div class="line">    public MyArrayList(int initialCapacity)&#123;</div><div class="line">        if(initialCapacity&lt;0)&#123;</div><div class="line">            try &#123;</div><div class="line">                throw new Exception();</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        elementDate = new Object[initialCapacity];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void add(Object obj) &#123;</div><div class="line">        if(size==elementDate.length) &#123;</div><div class="line">            Object[] newArrayList = new Object[size*2+1]; //当数组达到上限，创建新的数组对象</div><div class="line">　　　　　　//System.arraycopy(elementDate, 0, newArrayList, 0, elementDate.length);  //使用arraycopy方法也没问题，代码更简洁</div><div class="line">            for(int i=0; i&lt;newArrayList.length; i++) &#123;</div><div class="line">                newArrayList[i] = elementDate[i];   //遍历旧数组元素，存入新数组</div><div class="line">                elementDate = newArrayList;      //将新数组地址传递给旧数组</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        elementDate[size++] = obj;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="对于remove方法的详细说明"><a href="#对于remove方法的详细说明" class="headerlink" title="对于remove方法的详细说明"></a>对于remove方法的详细说明</h3><ul>
<li><p>remove方法可以根据索引值（index）或者指定对象删除元素：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void remove(int index) &#123;</div><div class="line">       rangeCheck(index);</div><div class="line">       elementDate[index] = null;</div><div class="line">       System.arraycopy(elementDate, index+<span class="number">1</span>, elementDate, index, elementDate.length-(index+<span class="number">1</span>));</div><div class="line">       size--;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>当出现索引越界时，调用方法rangeCheck，代码：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public void rangeCheck(int index) &#123;</div><div class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> <span class="params">||</span> index &gt;= this.size) &#123;   </div><div class="line">            try &#123;</div><div class="line">                throw new Exception();</div><div class="line">            &#125;catch(Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>remove方法还有个重载（override）方法：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public boolean remove(Object o) &#123;</div><div class="line">        <span class="keyword">if</span> (o == null) &#123;</div><div class="line">            <span class="keyword">for</span> (int index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">                <span class="keyword">if</span> (elementData[index] == null) &#123;</div><div class="line">                    fastRemove(index);             <span class="regexp">//fast</span>Remove方法类似于索引删除方法</div><div class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (int index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;   <span class="regexp">//</span>此处用的equals方法，为对象的值比较</div><div class="line">                    fastRemove(index);</div><div class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;　　　　　　　　　　　　<span class="regexp">//</span>这里<span class="keyword">return</span>后返回boolean，所以只会删除第一次出现的对象　　　　　　　　</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>remove方法的测试结果：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">        ArrayList list = new ArrayList();</div><div class="line">        list.add(<span class="string">"aa"</span>);</div><div class="line">        list.add(<span class="string">"bb"</span>);</div><div class="line">        list.add(new Date());</div><div class="line">        list.add(new Date());</div><div class="line">        list.remove(new Date());</div><div class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</div><div class="line">            System.out.println(list.get(i));</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><img src="1.jpg" alt="loading~~~"></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;List 接口的大小可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;（Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list.）&lt;/p&gt;
&lt;p&gt;&lt;em&gt;每个 ArrayList 实例都有一个容量。该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向 ArrayList 中不断添加元素，其容量也自动增长。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;（Each ArrayList instance has a capacity. The capacity is the size of the array used to store the elements in the list. It is always at least as large as the list size. As elements are added to an ArrayList, its capacity grows automatically. ）&lt;br&gt;
    
    </summary>
    
      <category term="DATA STRUCTURES" scheme="http://yoursite.com/categories/DATA-STRUCTURES/"/>
    
    
      <category term="Data Structures" scheme="http://yoursite.com/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>冒泡算法的逻辑分析</title>
    <link href="http://yoursite.com/2017/05/06/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/05/06/冒泡排序/</id>
    <published>2017-05-06T09:06:41.622Z</published>
    <updated>2017-05-06T09:07:08.773Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><link rel="stylesheet" type="text/css" href="/css/lib/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><em>在给定的一个数据中，我们有时候需要将数据对象进行某种顺序排列，常见的排列方式为升序或是降序，冒泡算法是处理这类排序的经典方法</em>。</p>
<blockquote>
<p>给定一个数组</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int[] arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>要将这个降序数组重排为升序数组，我们可以通过：</p>
</blockquote>
<ul>
<li><p>将9和8进行比较，较大者和较小者换位–&gt;{8,9,7,6,5}</p>
</li>
<li><p>将9和7进行比较，较大者和较小者换位–&gt;{8,7,9,6,5}</p>
</li>
</ul>
<p>…</p>
<ul>
<li>最终得到{8,7,6,5,9}<a id="more"></a>
</li>
</ul>
<h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现:"></a>基本实现:</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int[] arr = &#123; <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span> &#125;;</div><div class="line">        </div><div class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</div><div class="line">            int temp = arr[i];</div><div class="line">            arr[i] = arr[i + <span class="number">1</span>];</div><div class="line">            arr[i + <span class="number">1</span>] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>之后，需要开始第二轮的排序，自然想到使用嵌套for循环来实现：</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int[] arr = &#123; <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span> &#125;;</div><div class="line">        </div><div class="line">    <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span>; j++) &#123;</div><div class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</div><div class="line">                int temp = arr[i];</div><div class="line">                arr[i] = arr[i + <span class="number">1</span>];</div><div class="line">                arr[i + <span class="number">1</span>] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这时，我们会发现在遍历过程中，每一次遍历都会增加一次不必要的重复比较，具体逻辑分析过程可以列举每一次的两个数字比较发现。因此在第二次for循环中，随着遍历的递进，都需要减少1次arr.length,实际上可以在内部for循环中将循环条件改为arr.length-1 —&gt;  arr.length-(1+j):</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">int[] arr = &#123; <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span> &#125;;</div><div class="line">        </div><div class="line">    <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span>; j++) &#123;</div><div class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; arr.length - (<span class="number">1</span> + j); i++) &#123;</div><div class="line">           <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</div><div class="line">                int temp = arr[i];</div><div class="line">                arr[i] = arr[i + <span class="number">1</span>];</div><div class="line">                arr[i + <span class="number">1</span>] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>现在，这个排序算法已经很好了，但是还可以继续优化,如果我们遇到仅需要一次排序就可以完成的数组，如:{9，5，6，7，8}，我们可以通过加入if和boolean来升级当前排序：</p>
</blockquote>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果:"></a>最终效果:</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int[] arr = &#123; <span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> &#125;;</div><div class="line">    boolean b = <span class="literal">true</span>;</div><div class="line">        </div><div class="line">    <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span>; j++) &#123;</div><div class="line">        b = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span> - j; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</div><div class="line">                int temp = arr[i];</div><div class="line">                arr[i] = arr[i + <span class="number">1</span>];</div><div class="line">                arr[i + <span class="number">1</span>] = temp;</div><div class="line">                b = <span class="literal">true</span>;</div><div class="line">                System.out.println(Arrays.toString(arr));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(b == <span class="literal">false</span>) <span class="keyword">break</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>最简单的排序算法,但是很实用</strong>!!!</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;在给定的一个数据中，我们有时候需要将数据对象进行某种顺序排列，常见的排列方式为升序或是降序，冒泡算法是处理这类排序的经典方法&lt;/em&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个数组&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;int[] arr = &amp;#123;&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;要将这个降序数组重排为升序数组，我们可以通过：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;将9和8进行比较，较大者和较小者换位–&amp;gt;{8,9,7,6,5}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将9和7进行比较，较大者和较小者换位–&amp;gt;{8,7,9,6,5}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最终得到{8,7,6,5,9}
    
    </summary>
    
      <category term="ALGORITHMS" scheme="http://yoursite.com/categories/ALGORITHMS/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>常用容器（Collection）实现类总结（零）</title>
    <link href="http://yoursite.com/2017/05/06/%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93_one/"/>
    <id>http://yoursite.com/2017/05/06/常用容器总结_one/</id>
    <published>2017-05-06T08:49:33.558Z</published>
    <updated>2017-05-06T09:19:58.476Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><link rel="stylesheet" type="text/css" href="/css/lib/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><em>容器（Collection） 层次结构中的根（root）接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何直接 实现：它提供更具体的子接口（如 Set 和 List）实现。此接口通常用来传递 collection，并在需要最大普遍性的地方操作这些 collection。</em></p>
<p>（The root interface in the collection hierarchy. A collection represents a group of objects, known as its elements. Some collections allow duplicate elements and others do not. Some are ordered and others unordered. The JDK does not provide any direct implementations of this interface: it provides implementations of more specific subinterfaces like Set and List. This interface is typically used to pass collections around and manipulate them where maximum generality is desired.）<br><a id="more"></a></p>
<p><img src="1.jpg" alt="loading~~~"></p>
<blockquote>
<p>其中，常用的具体类有：</p>
</blockquote>
<ul>
<li><p>ArrayList：底层实现为数组（Array），可以重复放置元素，且为线性排列。优点是查找方便，缺点是增、删速率低。</p>
</li>
<li><p>LinkedList：底层实现为链表（Link list），优点是删除和添加的效率很高，但随机访问元素时效率较ArrayList类低。</p>
</li>
<li><p>HashMap：通过键值对（Key—Value）映射的数据结构（类似于字典的用法），且Key有且唯一，但是一个Key可以一对多个Value，细节后续讨论。优点是可以通过Key快速查找并操作相关数据，很方便。</p>
</li>
<li><p>HashSet：不允许重复的对象传入，且不能保证传入数据能够有序迭代（ It makes no guarantees as to the iteration order of the set）。优点是HashSet利用Hash函数进行了查询效率上的优化。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;容器（Collection） 层次结构中的根（root）接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何直接 实现：它提供更具体的子接口（如 Set 和 List）实现。此接口通常用来传递 collection，并在需要最大普遍性的地方操作这些 collection。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;（The root interface in the collection hierarchy. A collection represents a group of objects, known as its elements. Some collections allow duplicate elements and others do not. Some are ordered and others unordered. The JDK does not provide any direct implementations of this interface: it provides implementations of more specific subinterfaces like Set and List. This interface is typically used to pass collections around and manipulate them where maximum generality is desired.）&lt;br&gt;
    
    </summary>
    
      <category term="DATA STRUCTURES" scheme="http://yoursite.com/categories/DATA-STRUCTURES/"/>
    
    
      <category term="Data Structures" scheme="http://yoursite.com/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>迭代器小结</title>
    <link href="http://yoursite.com/2017/05/06/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2017/05/06/迭代器小结/</id>
    <published>2017-05-06T07:11:01.697Z</published>
    <updated>2017-05-06T08:24:25.574Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><link rel="stylesheet" type="text/css" href="/css/lib/hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="为什么使用迭代器"><a href="#为什么使用迭代器" class="headerlink" title="为什么使用迭代器?"></a>为什么使用迭代器?</h2><ul>
<li>数组的遍历，可以通过for循环来实现，其原因是数组对于数据的储存是有序的(order)；但是，对于Set这种无序(no order)              的数据结构，就无法通过for循环来实现，此时，我们就需要引入一种新的访问方式来实现对数据的操作——迭代器。<a id="more"></a>
</li>
</ul>
<p>迭代器是一种轻量级的对象操作，其接口有四个抽象方法：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public interface Iterator&lt;E&gt; &#123;</div><div class="line"></div><div class="line">    boolean hasNext();</div><div class="line">    E <span class="keyword">next</span>();</div><div class="line">    default void remove() &#123;</div><div class="line">        throw new UnsupportedOperationException(<span class="string">"remove"</span>);</div><div class="line">    &#125;</div><div class="line">    default void forEachRemaining(Consumer&lt;? <span class="keyword">super</span> E&gt; action) &#123;</div><div class="line">        Objects.requireNonNull(action);</div><div class="line">        <span class="keyword">while</span> (hasNext())</div><div class="line">        action.accept(<span class="keyword">next</span>());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>方法简介:</p>
</blockquote>
<p>–Object next()：返回集合里下一个元素。</p>
<p>–boolean hasNext()：如果被迭代的集合还元素没有被遍历，则返回true。</p>
<p>–void remove() ：删除集合里上一次next方法返回的元素</p>
<p>–void forEachRemaining(Consumer action)，这是Java 8为Iterator新增的默认方法，该方法可使用Lambda表达式来遍历集合元素。</p>
<blockquote>
<p>迭代器的内部简单实现：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SimpleIter</span> &#123;</span></div><div class="line">        private int size =elem.length;</div><div class="line">        private int coursor=-<span class="number">1</span>;      <span class="regexp">//</span>由实现的方法可知，游标在开始遍历List的时候从下标【<span class="number">0</span>】开始，所以初始值赋予-<span class="number">1</span></div><div class="line">    </div><div class="line">    public int size()&#123;</div><div class="line">        <span class="keyword">return</span> this.size;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public boolean hasNext()&#123;</div><div class="line">        <span class="keyword">return</span> coursor+<span class="number">1</span>&lt;size;       <span class="regexp">//</span>为了防止下标越界，所以coursor+<span class="number">1</span>小于List长度</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String <span class="keyword">next</span>()&#123;</div><div class="line">        coursor++;</div><div class="line">        <span class="keyword">return</span> elem[coursor];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void remove()&#123;</div><div class="line">        System.arraycopy(elem, coursor+<span class="number">1</span>, elem, coursor,this.size-(coursor+<span class="number">1</span>)); </div><div class="line">        this.size--;</div><div class="line">        this.coursor--;              <span class="regexp">//</span>为了使游标可以指向删除某元素之后的正确指向，每次删除元素，需要coursor-<span class="number">1</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么使用迭代器&quot;&gt;&lt;a href=&quot;#为什么使用迭代器&quot; class=&quot;headerlink&quot; title=&quot;为什么使用迭代器?&quot;&gt;&lt;/a&gt;为什么使用迭代器?&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数组的遍历，可以通过for循环来实现，其原因是数组对于数据的储存是有序的(order)；但是，对于Set这种无序(no order)              的数据结构，就无法通过for循环来实现，此时，我们就需要引入一种新的访问方式来实现对数据的操作——迭代器。
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
</feed>
